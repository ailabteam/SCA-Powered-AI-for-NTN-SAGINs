# SCA-Powered-AI-for-NTN-SAGINs (SPAIN)

## üéØ Project Overview

This repository serves as a comprehensive resource for the study and implementation of **Successive Convex Approximation (SCA)** algorithms and their variants. Our primary focus is on applying SCA to solve challenging **Non-Convex Optimization** problems arising in **Non-Terrestrial Networks (NTN)** and **Satellite-Aided Global Information Networks (SAGINs)**.

The project emphasizes the crucial intersection between Optimization Theory and modern Artificial Intelligence (AI) frameworks, including Federated Learning (FL), Graph Neural Networks (GNN), and Transfer Learning (TL).

## üöÄ Repository Structure

The core source code resides within the `src/` directory, organized into four main development phases:

| Directory | Description | Technical Focus |
| :--- | :--- | :--- |
| `src/01_SCA_Fundamentals/` | Foundational implementations of basic SCA and its core techniques. | Theoretical background, clean code for core mechanics. |
| `src/02_Advanced_SCA_Algorithms/` | Advanced SCA methods for large-scale, complex, or decentralized optimization. | Scalability, parallel optimization, specialized constraint handling. |
| `src/03_AI_Integration_Frameworks/` | Combining SCA with leading AI paradigms (FL, GNN, TL). | Hybrid algorithms, optimizing AI communication overhead. |
| `src/04_Satellite_Use_Cases/` | Real-world NTN/SAGINs simulation scenarios and performance validation. | Practical application and comparative analysis. |
| `utils/` | Helper functions for channel modeling, plotting (outputting PDFs), and common utilities. | Reusability and simulation environment setup. |
| `configs/` | Parameter management files (e.g., system parameters, channel configs). | Efficient configuration management. |

## üõ†Ô∏è Environment Setup (Conda)

To ensure consistency, please use the provided `environment.yml` to set up your Conda environment:

```bash
conda env create -f environment.yml
conda activate sca-ntn-env
```

**Note:** All plotted results generated by the source code (`.py` files) will be saved as **PDF files** in the project root or a designated `output/` folder (to maintain clean code execution).

## üìö Detailed Tutor Roadmap (12 Key Tasks)

This section details the specific tasks we aim to cover during the development of this repository, organized by complexity and application.

### Phase I: SCA Fundamentals (`src/01_SCA_Fundamentals`)

| Task ID | Title | Description and SCA Technique |
| :--- | :--- | :--- |
| **Task 1** | **Sum-Rate Maximization (Power Allocation)** | Implement basic SCA using the **First-Order Taylor Expansion** to transform the non-concave objective (SINR log function) into a sequence of convex sub-problems. |
| **Task 2** | **Fractional Programming (Dinkelbach's Method & SCA)** | Solve generalized fractional programs (e.g., maximizing the ratio of two functions) using the parametric Dinkelbach's method combined with SCA for the inner optimization loop. |
| **Task 3** | **Difference of Convex (DCP) Programming** | Implement the CCCP (Concave-Convex Procedure) algorithm to handle objectives/constraints that can be decomposed as the difference of two convex functions. |

### ‚úÖ Task 1: Sum-Rate Maximization (Analysis)

The implementation in `src/01_SCA_Fundamentals/power_allocation_sca.py` successfully demonstrates the core SCA loop.

#### Key Results:
*   **Convergence:** The algorithm converged stably in 16 iterations (typical for medium-scale SCA problems).
*   **Optimal Strategy:** The optimal power allocation follows a strong **Channel-Selection** or **Water-Filling** strategy. Out of the 5 users, virtually all system power was allocated to a single user (User 5: $\sim 0.5$ W), while the remaining users received the minimum power ($\sim 10^{-6}$ W).
*   **Conclusion:** This validates that in interference-limited scenarios, the non-convex Sum-Rate maximization solution found by SCA dictates prioritizing the user with the best channel gain to minimize aggregate interference and maximize total throughput.

### ‚úÖ Task 2: Fractional Programming (Dinkelbach-SCA Analysis)

The implementation in `src/01_SCA_Fundamentals/energy_efficiency_sca.py` demonstrates the application of Dinkelbach's method (Outer Loop) combined with SCA (Inner Loop) to solve the non-convex fractional problem of maximizing Energy Efficiency (EE).

#### Key Results:
*   **Methodology:** The nested Dinkelbach-SCA loop proved to be highly robust and converged rapidly in just 5 iterations.
*   **Optimal Strategy:** Unlike Sum-Rate maximization (Task 1) which utilizes high power to maximize capacity, EE maximization finds a trade-off. The optimal solution drastically **reduced the transmit power** (e.g., from 0.5W total in Task 1 down to $\sim 0.013$ W) by prioritizing the single best channel, resulting in a lower Sum-Rate but achieving significantly higher Energy Efficiency (e.g., $110+$ bits/Joule).
*   **Conclusion:** This task highlights that for energy-constrained NTN/SAGINs, the Dinkelbach-SCA method is essential for finding the optimal power settings that maximize the system's operational lifespan by using power most efficiently.

### ‚úÖ Task 3: Difference of Convex (DCP/CCCP) Analysis

The implementation in `src/01_SCA_Fundamentals/weighted_rate_utility_sca.py` successfully demonstrates the application of SCA/CCCP to maximize a complex utility function: $F(\mathbf{p}) = \text{Sum-Rate} - \alpha \cdot \text{Total Interference}$. This structure falls under DC Programming ($\max (\text{Concave} - \text{Convex})$).

#### Key Results:
*   **CCCP Mechanism:** The algorithm maximizes the concave Sum-Rate approximation while linearly penalizing the convex Total Interference term. This ensures that the sub-problem remains convex (Max Concave) and stable.
*   **Extreme Interference Avoidance:** Due to the large penalty factor ($\alpha=100$), the resulting optimal solution utilizes minimal transmit power ($\sim 4.2$ mW total), drastically suppressing interference and focusing resources exclusively on the strongest channel, validating SCA's ability to handle aggressive cost functions.

### Phase II: Advanced SCA Algorithms (`src/02_Advanced_SCA_Algorithms`)

| Task ID | Title | Description and SCA Technique |
| :--- | :--- | :--- |
| **Task 4** | **Distributed SCA (ADMM Integration)** | Develop an ADMM-based distributed SCA framework, crucial for massive NTN deployments, where the overall problem is decoupled into local optimization tasks solved by SCA. |
| **Task 5** | **Non-Convex Constraint Handling** | Implement techniques to handle complex non-convex constraints (e.g., quality-of-service (QoS) constraints or rate constraints) by replacing them with convex approximations (linear/affine approximations). |
| **Task 6** | **SCA Convergence Acceleration** | Explore methods to boost the convergence speed and robustness of SCA, focusing on advanced warm-start strategies and adaptive step-size adjustments (e.g., trust region methods). |

### ‚úÖ Task 4: Distributed SCA (ADMM-SCA Analysis)

The implementation in `src/02_Advanced_SCA_Algorithms/admm_sca_distributed_power.py` demonstrates the integration of ADMM (Outer Loop) and SCA (Inner Loop) to find a global consensus power allocation ($\mathbf{Z}$) across multiple distributed nodes.

#### Key Results:
*   **Decentralized Optimization:** The ADMM framework successfully decomposed the global optimization into local SCA sub-problems ($\mathbf{P}_i$) penalized by the consensus deviation ($\mathbf{Z}$ and $\mathbf{U}_i$).
*   **Convergence and Stability:** The ADMM outer loop converged rapidly (e.g., 3 iterations) due to its inherent efficiency. However, the reliance on stable local SCA solutions was highlighted by **frequent solver failures** in the inner loop, emphasizing the need for robust parameter tuning ($\rho$, Trust Region) in nested SCA/ADMM algorithms.
*   **Relevance to NTN:** This architecture is fundamental for managing resources in complex decentralized scenarios like **Federated Learning over Satellite Networks** (Task 7) or distributed beamforming control.

### ‚úÖ Task 5: Non-Convex Constraint Handling Analysis

The implementation in `src/02_Advanced_SCA_Algorithms/non_convex_qos_sca.py` tackles the Power Minimization problem under a non-convex Quality-of-Service (QoS) rate constraint ($R_k \ge R_{\min}$).

#### Key Results & Learning Outcome:
*   **Methodology:** The non-convex rate constraint was correctly transformed into a sequence of convex constraints using a **first-order Taylor approximation** as a convex upper bound for the concave term $\log(B_k(\mathbf{p}))$.
*   **Infeasibility Challenge:** The algorithm consistently resulted in an **"infeasible"** status for the convex sub-problem. This is a critical learning outcome, demonstrating that the Taylor approximation, while ensuring convexity, can be too restrictive (over-conservative) at the initial point, effectively eliminating the feasible region of the sub-problem.
*   **Conclusion:** This task successfully illustrates a fundamental challenge in applying SCA to constrained problems. In practical scenarios, this infeasibility is typically resolved by introducing **slack variables** and penalty terms (a more advanced technique) or by first solving a **feasibility search problem** to find a valid starting point.


### ‚úÖ Task 6: SCA Convergence Acceleration Analysis

The implementation in `src/02_Advanced_SCA_Algorithms/adaptive_sca_convergence.py` utilizes the Adaptive Trust Region (ATR) technique to enhance the convergence speed of Sum-Rate maximization.

#### Key Results & Learning Outcome:
*   **Acceleration:** ATR significantly reduced the initial search phase, achieving high-quality solutions much faster (e.g., reaching peak performance in 7 iterations compared to 16 in Task 1). The adaptive mechanism ($\rho$) correctly increased the step size ($\Delta$) during periods of good improvement.
*   **Stability Trade-off:** The experiment exposed a trade-off. While fast, the algorithm showed susceptibility to numerical errors (`Rate=nan` and `No improvement`) as it neared convergence, requiring frequent reduction of the Trust Region radius.
*   **Conclusion:** Adaptive methods are vital for real-time optimization in dynamic NTN environments, but require careful numerical stabilization techniques (e.g., handling extreme power values or gradients) to maintain robustness near the optimal point.


### Phase III: AI Integration Frameworks (`src/03_AI_Integration_Frameworks`)

| Task ID | Title | Description and Integration |
| :--- | :--- | :--- |
| **Task 7** | **SCA-Optimized Federated Learning (FL)** | Use SCA to optimize the **communication resources** (power, bandwidth, scheduling) of the satellite/ground clients in an FL setting, minimizing training latency or energy cost while maintaining learning performance. |
| **Task 8** | **GNN-Aided Resource Allocation** | Implement a hybrid system where a **GNN** models the dynamic NTN topology and predicts traffic/channel state, and **SCA** then uses these learned features to perform optimal dynamic resource allocation (e.g., routing). |
| **Task 9** | **Transfer Learning for SCA Warm-Start** | Demonstrate how optimal solutions derived from one SCA problem instance (Source Domain, e.g., low-density network) can be used via Transfer Learning to provide a highly effective warm-start for a new SCA problem (Target Domain, e.g., high-density network). |


### ‚úÖ Task 7: SCA-Optimized Federated Learning Analysis

The implementation in `src/03_AI_Integration_Frameworks/fl_resource_sca.py` integrates SCA into the communication phase of an FL environment, aiming to minimize communication time by maximizing the Sum-Rate of parameter transmission.

#### Key Results & Learning Outcome:
*   **Architectural Integration:** SCA is successfully implemented as an **Inner Loop Optimization Module**, which runs at the start of every FL communication round (before model aggregation) to decide the optimal transmit power configuration.
*   **Resource Strategy:** The SCA solution reaffirmed the Sum-Rate strategy: concentrating maximum allowed power on the single client with the best channel (Channel Selection). In the FL context, this translates to **prioritizing the fastest links** to reduce overall communication latency.
*   **Warm-Start for Stability:** The sequential calling of SCA in subsequent FL rounds (using the previous optimal power as a starting point) demonstrates effective **Warm-Starting**, ensuring near-instantaneous convergence of the resource optimization problem in a static channel environment.


### ‚úÖ Task 8: GNN-Aided Resource Allocation Analysis

The implementation in `src/03_AI_Integration_Frameworks/gnn_resource_sca.py` constructs a novel hybrid model where a Graph Convolutional Network (GCN) predicts the Channel State Information (CSI), and SCA uses this predicted CSI to perform optimal power allocation.

#### Key Results & Learning Outcome:
*   **Decoupling AI and Optimization:** This task confirms the ideal hybrid architecture: the GNN handles the non-linear feature extraction and prediction task (forecasting the Interference/Channel Matrix $\mathbf{H}$), while the SCA module handles the final non-convex optimization, ensuring the resulting power vector $\mathbf{p}^*$ adheres to hard physical constraints.
*   **Performance Trade-off:** The hybrid model achieved a Sum-Rate approximately **15.7% lower** than the theoretical baseline (SCA with perfect CSI). This demonstrates the practical trade-off in dynamic NTN environments: accepting a modest performance loss in exchange for fast, predictive optimization using imperfect CSI derived from GNNs.


### Phase IV: NTN/SAGINs Practical Applications (`src/04_Satellite_Use_Cases`)

| Task ID | Title | Description and Application |
| :--- | :--- | :--- |
| **Task 10** | **Beamforming Optimization in Dynamic NTN** | Apply SCA to design complex non-convex **MIMO/Beamforming** weight vectors to maximize SINR or sum-rate under interference constraints in dynamic satellite environments (LEO/MEO). |
| **Task 11** | **Energy Efficiency Maximization** | Solve the challenging non-convex fractional programming problem of maximizing system **Energy Efficiency (Bits/Joule)** by jointly optimizing transmit power and bandwidth using SCA. |
| **Task 12** | **3D Trajectory Optimization (UAV/LEO)** | Utilize SCA to optimize the non-convex constraints involved in **3D Trajectory Planning** for UAVs or low-orbit satellites, balancing connectivity, coverage, and propulsion energy. |

## ü§ù Contribution

We welcome contributions from the community. Please refer to the designated files for contribution guidelines.

---
